#!/usr/bin/env python2.7
import sys, argparse, pybedtools, scipy.stats
from collections import defaultdict
import numpy as np

parser = argparse.ArgumentParser(description="""

 Given gc.bedGraph (chr, start, end, pct_gc)
 Generate a corresponding gc_fe_table.txt: chr, start, end, gc, treatcov, controlcov, fe

 Typical procedure beforehand:

 bedtools makewindows -g hg19.genome -w 100 -s 100 | bedtools intersect -v -a - -b excludedregions.bed | awk '$3-$2 == 100 {OFS="\t"; print $1,$2,$3}' | bedtools nuc -fi hg19.fa -bed - | awk '!/^#/ {OFS="\t"; print $1,$2,$3,$5}' > gc.bedGraph

 Output header: chr, start, end, pct_gc, test_value, control_value, test/control value (FE), label, [CNV if used]

 
    """, formatter_class= argparse.RawTextHelpFormatter)
parser.add_argument('--table', '-i', '-f',
                   type= str,
                   help='''Path to gc.bedGraph.''')
parser.add_argument('--gccol', 
                   type=int, default=4,
                   help='''Assuming gc.bedGraph, default is 4. Change if necessary.''')
parser.add_argument('--mincov', 
                   type=float, default=2**-8,
                   help='''Min cov in bin for both treat and control. Default=2**-8.''')

parser.add_argument('--addorisignal', '-a', 
                   type=str, default=False,
                   help='''Add origin signal to bins. Begin on avg ever Nth bin and extend for M bins on avg. Provide comma-separated N,M -- suggestion for 100 bp bins = 300,10''')

parser.add_argument('--orisignalparams', '-p', 
                   type=str, default='20,3',
                   help='''If adding origin signal to bins, this controls mean and stdev of additional signal. default = 20,3 ''')

## TODO: use 'enrichment' instead of 'ori' -- as this can be thought of more generally than ORIs or NS-seq
##parser.add_argument('--addenrichmentsignal', '-a', 
##                   type=str, default=False,
##                   help='''Add enrichment signal to bins. Begin on avg ever Nth bin and extend for M bins on avg. Provide comma-separated N,M -- suggestion for 100 bp bins = 300,10''')
##
##parser.add_argument('--enrichmentsignalparams', '-p', 
##                   type=str, default='20,3',
##                   help='''If adding enrichment signal to bins, this controls mean and stdev of additional signal. default = 20,3 ''')


parser.add_argument('--addcnvsignal', '-c', 
                   type=str, default=False,
                   help='''Add or subtract signal to/from bins corresponding to gains or losses in copy number.
Begin on avg ever Xth bin and extend for Y bins on avg. Provide comma-separated X,Y.
Suggestion for 100 bp bins = 20000,1000 -- meaning you expect a 100 kb CNV every 2 Mb.
Note - this adds CNV signal de novo to the signal being generated.
However, it may be desired to add CNV signal in the same locations across multiple runs of this script.
If so, use --cnvlocations with path to desired alread-simulated signal+CNV file that had CNVs put in the last column.
Use --cnvcol to specify different column if it is not column 9.
Be conscious of avoiding using --addcnvsignal and --cnvlocations together -- i.e. don't do it unless intentionally adding CNVs on top of CNVs.
Note though that it currently will not provide the correct CNV copy number in the last column if making CNVs on top of CNVs.

Update: script has been altered such that if cnvlocations specified, then it will not also add more cnv signal...''')

parser.add_argument('--cnvparams', '-P', 
                   type=str, default='2,8,0.5',
                   help='''If adding CNV signal to bins, this controls the range of how large a gain or loss can be and the probability of gain (complement is prob of loss).
Provide comma-sep list as min,max,prob. default = 2,8,0.5 meaning you expect gains/losses ranging from 2-8-fold and expect gains to be equally likely as losses.''')

parser.add_argument('--cnvlocations', '-C', 
                   action='store_true', default=False,
                   help='''This tells the script that, for the --table argument, instead of giving a normal gc.bedGraph,
you have provided path to a file previously generated by this script using --addcnvsignal.
This will use the same copy numbers reported in that file.
It assumes the gccol=4 and cnvcol=9. Use --gccol and --cnvcol to alter.''')

parser.add_argument('--cnvcol', 
                   type=int, default=9,
                   help='''''')


args = parser.parse_args()


gc2felist = defaultdict(list)



################################################################ 
################ PROCESS ARGS IF NEED BED ######################
################################################################
''' Adjust column indexes to Python speak'''
gccol=args.gccol-1
cnvcol=args.cnvcol-1

''' Take care of enrichment parameters if need be'''
if args.addorisignal:
    N, M = (int(e) for e in args.addorisignal.strip().split(','))
    in_ori_prob = 1.0/N
    leave_ori_prob = 1.0/M
    in_origin = np.random.binomial(1, in_ori_prob)
    orimu, oristd = (float(e) for e in args.orisignalparams.strip().split(','))


''' Take care of CNV parameters if need be'''
if args.addcnvsignal:
    X, Y = (int(e) for e in args.addcnvsignal.strip().split(','))
    in_cnv_prob = 1.0/X
    leave_cnv_prob = 1.0/Y
    in_cnv = np.random.binomial(1, in_cnv_prob)
    cnv_min, cnv_max, cnv_is_gain_prob = (float(e) for e in args.cnvparams.strip().split(','))
    cnv_is_gain = np.random.binomial(1, cnv_is_gain_prob)
    cnv_magnitude = np.random.randint(cnv_min, cnv_max)
    if in_cnv:
        if cnv_is_gain:
            cnv_copy_num = 1.0 * cnv_magnitude
        else: #loss
            cnv_copy_num = 1.0 / cnv_magnitude
    else:
        cnv_copy_num = 1.0
    cnv_tag = str(cnv_copy_num)



################################################################
########################## EXECUTE #############################
################################################################
    
with open(args.table) as table:
    for row in table:
        if args.cnvlocations:
            whole_row = row.strip().split() ## To avoid taking the treat, control, FE, label, CNV cols from older sim_gc file (just want chr, start, end, gc)
            row = whole_row[:3] + [whole_row[gccol]]
            gc = 100*float(row[3])
            old_cnv_copy_num = float(whole_row[cnvcol])
        else:
            row = row.strip().split()
            gc = 100*float(row[gccol])
        treat = max(args.mincov, np.random.normal(gc,(gc+1e-100)**0.5))
        control = max(args.mincov, np.random.normal(1,0.05))
        region = "bg"
        
        if args.addorisignal: ## add enrichment signal on top of background
            if in_origin:
                    region = "origin"
                    treat += np.random.normal(orimu,oristd)
                    in_origin = 1 - np.random.binomial(1, leave_ori_prob)
            else:
                in_origin = np.random.binomial(1, in_ori_prob)
                
        if args.cnvlocations: ## CNV AFTER enrichment signal added
            treat *= old_cnv_copy_num
            cnv_tag = str(old_cnv_copy_num)
            
        elif args.addcnvsignal:
            if in_cnv:
                treat *= cnv_copy_num
                control *= cnv_copy_num
                in_cnv = 1 - np.random.binomial(1, leave_cnv_prob)
            else: #not in CNV
                cnv_copy_num = 1.0 ## Was not in CNV -- need this here before re-calculat in_cnv
                in_cnv = np.random.binomial(1, in_cnv_prob)
                if in_cnv: ## to avoid calculating the next lines too often, only re-calculate when back in CNV
                    cnv_is_gain = np.random.binomial(1, cnv_is_gain_prob)
                    cnv_magnitude = np.random.randint(cnv_min, cnv_max)
                    if cnv_is_gain:
                        cnv_copy_num = 1.0 * cnv_magnitude
                    else: #loss
                        cnv_copy_num = 1.0 / cnv_magnitude
            cnv_tag = str(cnv_copy_num)
        fe = treat/control
        row += [str(treat), str(control), str(fe), region]
        if args.cnvlocations or args.addcnvsignal:
            row += [cnv_tag]
        print ("\t").join(row)
